[{"title":"","tags":[],"categories":[],"author":"Adpro","excerpt":"\n啊哦~好像走丢了喵？\n","link":"/404","content":"\n啊哦~好像走丢了喵？\n"},{"title":"关于我","tags":[],"categories":[],"author":"Adpro","excerpt":"\nhii~\n\n你可以叫我Adpro，或者adproqwq，又或者adproawa，还有其他你愿意称呼我的称呼，不过不要太大恶意，我会默默碎掉的（\n\n业余的前端开发，喜欢猫猫（真的很可爱有没有！），如果","link":"/about","content":"\nhii~\n\n你可以叫我Adpro，或者adproqwq，又或者adproawa，还有其他你愿意称呼我的称呼，不过不要太大恶意，我会默默碎掉的（\n\n业余的前端开发，喜欢猫猫（真的很可爱有没有！），如果你有喜欢的番也可以推荐给我哦~\n\n先这样吧？\n"},{"title":"关于站点","tags":[],"categories":[],"author":"Adpro","excerpt":"\n这是Adpro的Blog，里面有好东西吗？\n\n来看看就知道啦！\n","link":"/about/site","content":"\n这是Adpro的Blog，里面有好东西吗？\n\n来看看就知道啦！\n"},{"title":"","tags":[],"categories":[],"author":"Adpro","excerpt":"","link":"/archives","content":""},{"title":"Adproの分类","tags":[],"categories":[],"author":"Adpro","excerpt":"","link":"/categories","content":""},{"title":"我的小伙伴们","tags":[],"categories":[],"author":"Adpro","excerpt":"\n本站信息：\n\n```text\n  链接：https://blog.adproqwq.top/\n  图标链接：https://blog.adproqwq.top/avatar.jpg\n  网站名称：A","link":"/links","content":"\n本站信息：\n\n```text\n  链接：https://blog.adproqwq.top/\n  图标链接：https://blog.adproqwq.top/avatar.jpg\n  网站名称：AdproのBlog\n  描述：Adpro的Blog，可能有有用的东西？\n  主题色：#39C5BB\n```\n\n按照如下格式在下方留言以添加友链！\n\n```text\n  链接：\n  图标链接：\n  站长昵称：\n  站长邮箱（可选）：\n  网站名称：\n  描述：\n  主题色（16进制色号！）：\n```\n\n可能有不少友链只是单向的哦~\n\n<YunLinks :links=\"frontmatter.links\" :random=\"frontmatter.random\" />\n"},{"title":"GKD本地订阅收录申请","tags":["GKD"],"categories":[],"author":"Adpro","excerpt":"\n请在下方评论区，按照[贡献文档](https://github.com/Adpro-Team/GKD_THS_List/blob/dev/CONTRIBUTING.md)的说明留言","link":"/posts/GKD%E6%9C%AC%E5%9C%B0%E8%AE%A2%E9%98%85%E6%94%B6%E5%BD%95%E7%94%B3%E8%AF%B7","content":"\n请在下方评论区，按照[贡献文档](https://github.com/Adpro-Team/GKD_THS_List/blob/dev/CONTRIBUTING.md)的说明留言"},{"title":"GKD规则编写之属性-1","tags":["GKD","教程"],"categories":["教程","GKD"],"author":"Adpro","excerpt":"\n# 0. 前言\n\n本教程不会有太多的图，大多数是理论讲解。\n\n那么，现在先来解释下什么叫`属性`：\n\n`属性`，是GKD的专有名词。由于GKD的规则采用`JSON`（为方便表述，下文的`JSON`包","link":"/posts/GKD%E8%A7%84%E5%88%99%E7%BC%96%E5%86%99%E4%B9%8B%E5%B1%9E%E6%80%A7-1","content":"\n# 0. 前言\n\n本教程不会有太多的图，大多数是理论讲解。\n\n那么，现在先来解释下什么叫`属性`：\n\n`属性`，是GKD的专有名词。由于GKD的规则采用`JSON`（为方便表述，下文的`JSON`包含`JSON5`和`TypeScript`）编写，那么有接触过`JSON`的就能很轻松地理解`属性`了，不会`JSON`的也不用慌，每个`属性`的介绍都会给出它的用法示例，`JSON`的概念也会同时说明~~，简直赚翻天，一篇教程，两种知识~~。\n\n那么给没有接触过`JSON`的同学介绍下：\n\n在`JSON`中，通常一个完整的语句由一个`键值对`组成\n\n何为`键值对`？就是指由`键`和`值`组成的形如下方这样的语句：\n\n```json\n键: 值\n```\n\n`键值对`间用`,`分隔。\n\n那么`属性`是什么？`属性`就是`键值对`中的`键`。\n\n了解了这些之后，我们就先来学习几个在规则编写中必需的`属性`。\n\n**需知：本教程采用JSON5**\n\n# 1. 正文\n\n## 1.1 id\n\n`id`属性是GKD识别应用的关键，一般而言是应用的包名。\n\n其用法为：\n\n```json\nid: '应用的id'\n```\n\n## 1.2 name\n\n不同于`属性选择器`中的`name属性`，这里的`name`指的是应用名称。\n\n其用法为：\n\n```json\nname: '应用名称'\n```\n\n## 1.3 groups\n\n从这里开始，我们引出一个概念：`列表`。\n\n### 1.3.1 列表\n\n打开GKD的默认订阅，再随便点开一个应用，你可以发现里面是这样的：![规则组](https://cdn.jsdelivr.net/gh/adproqwq/AdproImageHostingService@main/GKD教程-3.5rtwhri2jxg0.jpg)\n\n每一个开关就对应一个规则组，这么多个规则组组合起来就组成了列表。\n\n总而言之就是：一个应用就是一个列表，列表中有很多的规则组。\n\n### 1.3.2 定义\n\n`groups`的值应是一个数组，数组内应包含对象。\n\n数组就代表一个列表，每一个对象都是一个规则组。\n\n在`JSON`中，数组由一对`[]`包裹。那对象又是什么？\n\n对象由一对`{}`包裹，其内是一个**无序**的`键值对`集合\n\n例如：\n\n```json\n{\n\tname: '张三',\n\tbirthday: '2000.1.1',\n}\n```\n\n与\n\n```json\n{\n\tbirthday: '2000.1.1',\n\tname: '张三',\n}\n```\n\n是等价的。\n\n### 1.3.3 用法\n\n其用法为：\n\n```json\ngroups: [\n    {...},{...}\n]\n```\n\n## 1.4 key\n\n从这里开始，除特殊说明外，下面包括以后的所有`属性`都位于`groups`内的对象内部。\n\n------\n\n先看官方定义：\n\n> 当前规则组在列表中的唯一标识，也是客户端禁用/启用此规则组的依据\n>\n\n`key`属性，表示该规则组在列表中的唯一标识，可以理解为规则组在列表中的身份证。\n\n### 1.4.1 用法\n\n那么`key`属性的用法是什么呢？\n\n它的用法就是：\n\n```json\nkey: 常整数\n```\n\n### 1.4.2 注意事项\n\n要注意：每一个列表中有且只能有一个相同的`key`值，\n\n即：如果列表中已经存在了`key: 1`，那么就不能再有第二个`key: 1`。\n\n## 1.5 name\n\n你可能会很疑惑，为什么又有一个`name`？\n\n这两个`name`因为其所处位置的不同，其意义也不同。\n\n1.2介绍的`name`与`groups`是同一级，表示的是应用名称；\n\n而本节的`name`位于`groups`内，表示的是规则组名称。\n\n其用法为：\n\n```json\ngroups: [\n    {\n        name: '规则组名称'\n    }\n]\n```\n\n## 1.6 rules\n\n`rules`属性与`groups`属性雷同，它们的值都是数组，数组内部都是对象。\n\n但是与`groups`不同的是，`groups`的数组表示一个列表，而`rules`的数组表示规则组内的**子规则集（非官方说法）**。怎么去理解？\n\n每个对象都是一个`子规则`，这些对象共同构成一个数组，就是`子规则集`\n\n### 1.6.1 用法\n\n其用法如下：\n\n```json\ngroups: [\n    {\n        rules: [\n            {...}\n        ]\n    }\n]\n```\n\n### 1.6.2 特殊情况\n\n`rules`属性在特殊情况下可以简写。\n\n在`rules`的值数组内，有且只有一个对象时，可以简写为下面的样子：\n\n```json\ngroups: [\n    {\n        rules: '规则'\n    }\n]\n```\n\n## 1.7 matches\n\n以下`属性`在一般情况下位于`rules`内部\n\n------\n\n`matches`属性的值是由`选择器`组成的一条或多条字符串（也就是常说的`规则`），如果是多条字符串，那么`matches`的值为一个数组。\n\n### 1.7.1 用法\n\n其用法如下：\n\n1. 当值为一条字符串时：\n\n   ```json\n   groups: [\n       {\n           rules: [\n               {\n                   matches: '规则'\n               }\n           ]\n       }\n   ]\n   ```\n\n2. 当值为多条字符串时：\n\n   ```json\n   groups: [\n       {\n           rules: [\n               {\n                   matches: [\n                       '规则1',\n                       '规则2',\n                       ...\n                   ]\n               }\n           ]\n       }\n   ]\n   ```\n\n## 1.8 综合运用\n\n使用上面介绍的`属性`，可以写出一个简单的模板。\n\n```json\n{\n    id: '应用id',\n    name: '应用名称',\n    groups: [\n        {\n            key: 0,\n            rules: [\n                {\n                    matches: '规则'\n                }\n            ]\n        }\n    ]\n}\n```\n\n这个模板对于导入本地订阅的同学已经足够了，但是如果想要维护自己的订阅的话，这些是远远不够的。这就需要下篇的知识了。\n"},{"title":"GKD规则编写之属性-2","tags":["GKD","教程"],"categories":["教程","GKD"],"author":"Adpro","excerpt":"\n# 0. 前言\n\n本篇主要讲述在GKD规则编写中不必需，但常用的`属性`。\n\n如果没有看过上一篇的同学，请看完上一篇哦！\n\n# 1. 正文\n\n## 1.1 snapshotUrls\n\n`snapsh","link":"/posts/GKD%E8%A7%84%E5%88%99%E7%BC%96%E5%86%99%E4%B9%8B%E5%B1%9E%E6%80%A7-2","content":"\n# 0. 前言\n\n本篇主要讲述在GKD规则编写中不必需，但常用的`属性`。\n\n如果没有看过上一篇的同学，请看完上一篇哦！\n\n# 1. 正文\n\n## 1.1 snapshotUrls\n\n`snapshotUrls`属性通常位于`rules`属性内，与`matches`属性同级。\n\n`snapshotUrls`属性后接字符串，字符串的内容是快照的导入链接。\n\n那么，什么是快照？又有什么作用？\n\n### 1.1.1 快照\n\n以下对于`快照`的介绍来自@[Snoopy1866（锟斤拷）](https://github.com/Snoopy1866)\n\n> GKD 使用无障碍权限获取到某个广告弹窗的界面元素信息，并可以通过快照将界面元素信息永久保存，便于规则的书写和维护。\n>\n>PS：快照不同于截图。截图仅包含界面的图像信息，而快照不仅包含界面的图像信息，还包含界面的元素信息，例如控件的名称和属性，以及控件与控件之间的位置关系信息。\n\n### 1.1.2 格式\n\n`snapshotUrls`属性的格式为：\n\n```json\nsnapshotUrls: '快照链接'\n```\n\n`snapshotUrls`属性的值也可以是数组，格式如下：\n\n```json\nsnapshotUrls: [\n    '快照链接1',\n    '快照链接2',\n    '...',\n]\n```\n\n\n\n**请注意：快照链接必须以`https://i.gkd.li/i/`开头，关于如何获取该链接，可以前往@Snoopy1866编写的[教程处](https://github.com/Snoopy1866/blogs/blob/main/software/gkd/gkd-rule-tutorial/gkd-rule-tutorial.md)查看**\n\n`snapshotUrls`属性所处的位置：\n\n```json\n{\n    groups: [\n        rules: [\n        \tsnapshotUrls: '快照链接',\n    \t],\n    ]\n}\n```\n\n### 1.1.3 特殊情况\n\n特别地，如果`rules`属性被简写为`rules: 规则`时，`snapshotUrls`的位置应在：\n\n```json\n{\n    groups: [\n        rules: '规则',\n        snapshotUrls: '快照链接',\n    ]\n}\n```\n\n## 1.2 fastQuery\n\n`fastQuery`属性需要搭配`网页审查工具`使用。\n\n关于`网页审查工具`，可以前往@Snoopy1866编写的[教程](https://github.com/Snoopy1866/blogs/blob/main/software/gkd/gkd-rule-tutorial/gkd-rule-tutorial.md)处查看。\n\n### 1.2.1 格式\n\n`fastQuery`属性的接受的值的类型为：`boolean`类型，\n\n即：`true`或`false`，\n\n使用方法如下：\n\n```json\nfastQuery: true,\n```\n\n**注意：当`fastQuery`的值为`false`时，`fastQuery`属性应省略不写**\n\n### 1.2.2 说明\n\n关于`fastQuery`属性的说明：\n\n#### 1.2.2.1 什么时候使用`fastQuery`属性？\n\n当`rules`属性内的规则的满足下列条件：\n\n `末尾属性选择器`的`第一个属性选择表达式`符合下面的结构之一的选择器\n\n- `[id='abc']`\n- `[vid='abc']`\n- `[text='abc']`\n- `[text^='abc']`\n- `[text*='abc']`\n- `[text$='abc']`\n\n或者使用`||`将它们连接形成的逻辑表达式也符合条件，即如下格式：\n\n- `[id='abc' || id='abc2']`\n- `[id='abc' || vid='abc' || text='abc' || text^='abc' || text*='abc' || text$='abc']`\n\n下面给出实际示例：✅表示符合格式, ❎表示不符合格式\n\n- `A > B + C[id='x'][childCount=2]` ✅\n- `A > B + C[childCount=2][id='x']` ❎\n- `A > B + C[id='x' || text='manbaout' || text*='ikun'][childCount=2]` ✅\n- `A > B + C[childCount=2][id='x' || text='manbaout' || text*='ikun']` ❎\n\n这样一个选择器只能在右侧使用快速查询，为了在中间的子选择器也能使用\n\n额外规定如果属性选择器如果符合上面格式并且右侧是`<<n`，也能在局部使用快速查找\n\n示例：`A > B + C[id='x'][childCount=2] <<n D`中的`C[id='x'][childCount=2] <<n`可以使用局部快速查找\n\n下面给出满足局部查询优化的示例：✅表示符合格式, ❎表示不符合格式\n\n- `A > B + C[id='x'][childCount=2] <<n D` ✅\n- `A > B + C[childCount=2][id='x'] <<n D` ❎\n\n上面介绍的是只有一个局部选择器的情况，下面给出多个局部快速查找的的示例：\n\n如`A > C[id='x'] <<n D[id='y'] <<n E`，其中的`C[id='x'] <<n`和`D[id='y'] <<n`都可以使用局部快速查找\n\n而且只有`网页审查工具`出现`可快速查找`提示（即一个对勾）时，可以使用`fastQuery`属性。\n\n**注意：如果选择器不存在满足快速查找的格式, `fastQuery`是否开启都不影响查询复杂度**\n\n#### 1.2.2.2 `fastQuery`属性的位置\n\n1. 当`fastQuery`属性与`rules`属性同级时，该规则组的所有规则全部使用`fastQuery`。\n\n   可以理解为：在该规则组下全局开启`fastQuery`。\n\n2. 当`fastQuery`属性位于`rules`属性内的其中一个对象中时，仅对该`子规则集`开启`fastQuery`。\n\n   可以理解为：局部使用`fastQuery`\n\n## 1.3 activityIds\n\n`activityIds`属性需要搭配`网页审查工具`使用。\n\n这里拓展下，什么是activity？\n\n### 1.3.1 activity\n\nAndroid的Activity是一个应用组件，一个应用通常由多个彼此松散联系的activity组成，在这里，你只需要知道这个就足够了。\n\nGKD的activityIds与Android的Activity是一样的。\n\n### 1.3.2 介绍\n\n`activityIds`属性接受一个`String`类型（即字符串）的值 或者 一个`String`类型的数组\n\n值的内容是规则执行的activityId\n\n#### 1.3.2.1 activityIds属性的意义\n\n> 值的内容是规则执行的activityId\n\n如何理解这句话？\n\nactivityIds相当于是一个牢笼，将规则的生效范围局限在activityIds规定的Activity下。\n\n比如，一个规则A，在Activity1下能正常工作，但在Activity2下误触。\n\n这时，我们就需要用activityIds，将规则的生效范围限定在Activity1，使其不在Activity2生效\n\n#### 1.3.2.2 格式\n\n使用方法如下：\n\n```json\nactivityIds: 'activityId',\n```\n或\n```json\nactivityIds: [\n    \"activityId1\",\n    \"activityId2\",\n    ...\n],\n```\n\n#### 1.3.2.3 说明\n\n类比`fastQuery`属性，\n\n1. 当`activityIds`属性与`rules`属性同级时，该规则组的所有规则全部在`activityIds`规定的activity中生效。\n\n2. 当`activityIds`属性位于`rules`属性内的其中一个对象中时，在仅是该`子规则集`在`activityIds`规定的activity中生效。\n\n## 1.4 resetMatch\n\n`resetMatch`属性接受一个`string`类型的参数。\n\n可选参数为：`app`和`activity`。默认为`activity`。\n\n### 1.4.1 格式\n\n```json5\nresetMatch: 'app',\n\nresetMatch: 'activity',\n```\n\n### 1.4.2 说明\n\n#### 1.4.2.1 作用\n\n`resetMatch`属性的作用为：规定在规则因`actionMaximum`等原因进入冷却后，重新开始匹配的条件。\n\n当`resetMatch`的值为`app`时，规则冷却后，只有重新进入app才会重新开始匹配；\n\n当`resetMatch`的值为默认的`activity`时，规则冷却后，只要activity变化，就会重新开始匹配。\n\n**请注意：activity的变化并不一定伴随着activityId的变化。**\n\n#### 1.4.2.2 特殊情况\n\n当`resetMatch`的值为`activity`时，一般不会写进规则中。\n\n如：\n\n```json5\n{\n    resetMatch: 'activity',\n    rules: '',\n},\n```\n\n与\n\n```json5\n{\n    rules: '',\n},\n```\n\n完全等价，我们一般会选择下方的写法。\n\n#### 1.4.2.3 位置\n\n类比`fastQuery`属性，\n\n1. 当`resetMatch`属性与`rules`属性同级时，该规则组的所有规则全部使用`resetMatch`的设置。\n\n2. 当`resetMatch`属性位于`rules`属性内的其中一个对象中时，在仅是该`子规则集`使用`resetMatch`的设置。\n\n## 1.5 matchTime\n\n`matchTime`属性接受一个`Interger`类型的参数。\n\n其参数含义为：规则匹配时间，使用的单位是毫秒。\n\n那么为什么需要这么一个属性呢？\n\n### 1.5.1 作用\n\n我们看一下官方对其的说明：\n\n> 规则匹配时间，此规则参与查询屏幕节点时，等待一段时间，休眠此规则\n> 例如某些应用的`开屏广告`的`activityId`容易误触/太广泛，而开屏广告几乎只在应用切出来时出现，设置一个有限匹配时间能避免后续的误触\n\n可以看到，其是为了防止误触而出现的一个属性。\n\n一般来说：我们仅会在`开屏广告`类的规则使用到它，但是在特殊情况下，其他分类的规则也会使用。\n\n### 1.5.2 格式\n\n```json5\nmatchTime: 10000, // 设置为 10000 是最常见的\n```\n\n### 1.5.3 说明\n\n类比`fastQuery`属性，\n\n1. 当`matchTime`属性与`rules`属性同级时，该规则组的所有规则全部使用`matchTime`的设置。\n\n2. 当`matchTime`属性位于`rules`属性内的其中一个对象中时，在仅是该`子规则集`使用`matchTime`的设置。\n\n\n## 1.6 actionMaximum\n\n--TODO--"},{"title":"GKD规则编写之选择器-1","tags":["GKD","教程"],"categories":["教程","GKD"],"author":"Adpro","excerpt":"\n# 前言\n\n本教程仅为个人理解，可能不严谨，请见谅。\n\n本教程不会有太多的图~~，别问，问就是懒得截~~\n\nGKD的规则编写靠的就是选择器，选择器的作用就是根据信息去定位节点。\n\nGKD所使用的选择","link":"/posts/GKD%E8%A7%84%E5%88%99%E7%BC%96%E5%86%99%E4%B9%8B%E9%80%89%E6%8B%A9%E5%99%A8-1","content":"\n# 前言\n\n本教程仅为个人理解，可能不严谨，请见谅。\n\n本教程不会有太多的图~~，别问，问就是懒得截~~\n\nGKD的规则编写靠的就是选择器，选择器的作用就是根据信息去定位节点。\n\nGKD所使用的选择器是类似CSS的选择器的，所以如果写过CSS的上手会更快一些。\n\n下面正式开始。\n\n------\n\n# 语法\n\n先展示下官方的介绍：\n\n> 与 css 类似, 一个选择器由 属性选择器 和 关系选择器 交叉组成, 并且开头末尾必须是 属性选择器\n>\n> 示例 `div > img` 的结构是 `属性选择器 关系选择器 属性选择器`, 它表示选择一个 `img` 节点并且它父节点是 `div`, 这与相同 css 语法语义一致\n>\n> 另外 属性选择器 和 关系选择器 之前必须强制用空格隔开, 也就是 `div>img` 是非法的, 必须写成 `div > img`\n\n> 一个选择器由 属性选择器 和 关系选择器 交叉组成, 并且开头末尾必须是 属性选择器\n\n这句是什么意思呢？第二段也有例子，如果看不懂的话，用数学来举例就明白了：1+2\n\n式子里的1和2就是所谓`属性选择器`，+号就是所谓`关系选择器`，开头和末尾必须是`属性选择器`的原因也就知道了，因为像 1+2+ 这样的式子是不完整的。\n\n# 属性选择器\n\n官方的文档对于属性选择器的介绍太长，就不放全文了。\n\n## @\n\n现在介绍一下`@`。\n\n> `@` 表示选择此节点, 一条规则最后属性选择器 `@` 生效, 如果没有 `@`, 取最后一个属性选择器\n\n什么意思呢？这里用一条规则去举例：\n\n```\nFrameLayout > @FrameLayout > ViewGroup\n```\n\n现在的`@`在第二个`FrameLayout`处，就是告诉程序：你要点击的是这个`FrameLayout`，而不是其它的节点。\n\n如果现在将`@`删去，变成\n\n```\nFrameLayout > FrameLayout > ViewGroup\n```\n\n会是什么结果？程序就不会点击第二个`FrameLayout`，而是点击最后的`ViewGroup`了。\n\n可以将其理解为与下方的规则等价\n\n```\nFrameLayout > FrameLayout > @ViewGroup\n```\n\n## name属性\n\n上节规则中的`FrameLayout`、`ViewGroup`到底是什么？\n\n现在来介绍：name属性。\n\n~~不是什么重点就随便写写啦~~\n\n`FrameLayout`、`ViewGroup`，包括常见的`TextView`、`ImageView`等等，都是节点的name属性，代表着该节点的类型*（个人理解）*。\n\n> 由于该选择器主要用于 Android 平台, 节点的 name 都是 java 类如 android.text.TextView 这种形式\n\n`TextView`等价于``[name='TextView'||name$='.TextView']``，其它也是一样的。\n\n## 表达式\n\n表达式有`逻辑表达式`和`布尔表达式`，表达式一般跟在`name属性`后面，用`[]`括起来。\n\n看到这里，你就想到上节末尾的`[name='TextView'||name$='.TextView']`，没错，那就是一个表达式。\n\n表达式的作用是：限制`name属性`的范围。如果只写`FrameLayout`，那一个快照内有多少的`FrameLayout`，程序不能明白你要点击的是哪个`FrameLayout`。但是加上表达式后，程序就知道你要点击哪一个`FrameLayout`了\n\n### 布尔表达式\n\n> 布尔表达式 由 `属性名` `操作符` `值` 构成\n\n#### 属性名\n\n在网页审查工具中，红圈的地方就是属性名。![属性名展示](https://cdn.jsdelivr.net/gh/adproqwq/AdproImageHostingService@main/GKD教程-1.6gdio2c65tg0.png)\n\n在实际规则编写中，一般不允许使用从`left`往下的，除`childCount`和`index`以外的属性名。\n\n#### 操作符\n\n操作符有：`=`， `!=`， `>`， `<`， `>=`， `<=`， `^=`， `*=`， `$=`， `!^=`， `!*=`， `!$=`\n\n`^=`：`以...开始`\n`*=`：`包含`\n`$=`：`以...结束`\n`!^=`：`不以...开始`\n`!*=`：`不包含`\n`!$=`：`不以...结束`\n\n这里用`*=`举例：\n\n```\nTextView[text*='123']\n```\n\n这条规则的意思就是：选择`text`属性名中包含`123`的节点。\n\n其它是雷同的。\n\n#### 值\n\n值有4种类型：`null`，`boolean`，`string`，`int`\n\n- `null`，一般不用\n- `boolean`：使用`true`或者`false`，比较少见\n- `string`：使用\"、\\`、'之一成对包裹，内部字符转义使用`\\`。注意：`string`不支持多行字符，另外处于 `[0, 0x1F]` 的控制字符必须使用转义字符表示\n- `int`：匹配`0-9`的数字，仅支持10进制\n\n特别地，有些`操作符`只能在对应的类型使用。\n\n如`a>''`，学过数学的同学都知道：大于号是用来比较数字的大小的。同样的，`>`这个操作符只能用于`int`类型的值，但是例子却用来比较`string`类型的值，所以它永远是不成立的。放到规则编写里，这就是非法选择器。\n\n下面是`操作符`在`值`的类型中的可用性的表格（`-`表示不可用）：\n\n![可用性表格](https://cdn.jsdelivr.net/gh/adproqwq/AdproImageHostingService@main/GKD教程-2.5n9v0l4toxk0.png)\n\n### 逻辑表达式\n\n`逻辑表达式`有`操作符`：`||`和`&&`\n\n- `||`：表示`或`，即`||`的两边只需满足其一。`||`的两边常为`布尔表达式`\n- `&&`：表示`并且`，即`&&`的两边需要全部满足。`&&`的两边常为`布尔表达式`\n\n特别地，`&&`的优先级更高，即`[a>1||b>1&&c>1||d>1]`等价于`[a>1||(b>1&&c>1)||d>1]`\n"},{"title":"GKD规则编写之选择器-2","tags":["GKD","教程"],"categories":["教程","GKD"],"author":"Adpro","excerpt":"\n# 关系选择器\n\n上一篇讲完了`属性选择器`，现在来讲`关系选择器`\n\n`关系选择器`用于连接两个`属性选择器`，可以回忆一下1+2的例子，+号就是所谓`关系选择器`。\n\n`关系选择器`由两部分构成","link":"/posts/GKD%E8%A7%84%E5%88%99%E7%BC%96%E5%86%99%E4%B9%8B%E9%80%89%E6%8B%A9%E5%99%A8-2","content":"\n# 关系选择器\n\n上一篇讲完了`属性选择器`，现在来讲`关系选择器`\n\n`关系选择器`用于连接两个`属性选择器`，可以回忆一下1+2的例子，+号就是所谓`关系选择器`。\n\n`关系选择器`由两部分构成，分别是：`关系操作符`和`关系表达式`\n\n## 关系操作符\n\n`关系操作符`，用于指示查找节点的方向\n\n打个比方，将所有的节点比作一个大家庭，那么这个家庭里面就肯定会有兄弟姐妹、祖先后人。那么`关系操作符`就是用来描述两个节点间的关系。\n\n`关系操作符`有5种：`+`、`-`、`>`、`<`、`<<`\n\n### +\n\n`+`操作符，表示前置兄弟节点。\n\n何为前置兄弟节点？\n\n这里给一个样例：`A + B`\n\n用回那个比喻，A跟B就是家里的两兄弟，而且他们是“相邻”的兄弟（“相邻”的兄弟就是指大哥和二哥、三哥和四哥这样的数字相邻的兄弟）\n\nA是大哥，B就是二哥\n\n只能匹配相邻的兄弟节点，那岂不是很鸡肋？\n\n放心，在讲完`关系表达式`后，就不会让你觉得鸡肋了\n\n### -\n\n`-`操作符，表示后置兄弟节点。\n\n还是那个样例，不过把`+`换成`-`变成：`A - B`\n\nA和B还是家里的两兄弟，也还是“相邻”兄弟，但是现在：\n\nB是大哥，A是二哥\n\n总的来说，可以类比数学的逆运算，`-`操作符就是`+`操作符的逆运算\n\n### >\n\n`>`操作符，表示祖先节点。\n\n有请助教样例大哥：`A > B`\n\n祖先节点，字面意思：就是谁是谁祖先\n\n那么看到样例，A是B的祖先，很好理解吧\n\n但是祖先也有辈分之分啊，这个样例中，A就是B的爸爸~~（没错，你可以管你的爸爸叫祖先）~~\n\n还是那句话，讲完`关系表达式`就可以解锁更高级操作了\n\n### <\n\n`<`操作符，表示直接**子**节点\n\n还是助教大哥：`A < B`\n\n还是按照字面理解：谁是谁儿子\n\n样例中表达的就是：A节点是B节点儿子\n\n### <<\n\n`<<`操作符，表示子孙节点\n\n不说了，懂得都懂：`A << B`\n\n还是字面意思：谁是谁的子孙，也就是谁是谁的后代\n\n样例就是：A是B的后代\n\n## 关系表达式\n\n关系表达式分两种，`元组表达式`和`多项式表达式`。关系表达式被`()`括起来，并且位于关系操作符的后方\n\n### 元组表达式\n\n`元组表达式`由有序递增的正整数组成，可以理解为数学中的数列\n\n下面是几个`元组表达式`：\n\n- `(1)`\n- `(1,2,3,4,5)`\n- `(2,4,6)`\n\n### 多项式表达式\n\n`多项式表达式`中的`多项式`就是数学中的一元一次多项式，在`多项式表达式`中以n为未知数\n\n从本质来说，`多项式表达式`是`元组表达式`的另一种表达方式\n\n> 这个元组的数字满足集合 `{an+b|an+b>=1,n>=1}(a,b是常整数)` 如果集合为空集则表达式非法\n\n那么，根据初中数学相关知识，我们可以知道：\n\n1. 当a<=0时，存在一个等价的有限`元组表达式`，如：\n   - `(-n+4)`等价于`(1,2,3)`\n   - `(-3n+10)`等价于`(1,4,7)`\n\n2. 当a>0时，存在一个等价的无限`元组表达式`，如：\n   - `(n)`等价于`(1,2,3,...)`\n   - `(2n-1)`等价于`(1,3,5,...)`\n\n## 关系选择器\n\n> 将 关系操作符 和 关系表达式 连接起来就得到了 关系选择器\n\n### 用法解释\n\n以下是5个`关系选择器`：\n\n- `A +5 B`\n- `A -5 B`\n- `A >3 B`\n- `A <3 B`\n- `A <<n B`\n\n对于`A +5 B`，就是说：A是大哥，B就是六哥\n\n同样的，对于`A -5 B`，A是六哥，B是大哥\n\n对于`A >3 B`，A是爷爷（设为第1代），B是曾孙子（则B为第4代）\n\n但是`A <3 B`有些许不同，不知道你有没有注意到：在介绍`<`关系操作符时，`子`字被加粗了。\n\n因为`A <3 B`并不是曾孙子与爷爷的关系，而是三哥与爸爸的关系，即：A是B的三儿子\n\n对于`A <<n B`，A是B的祖先，由于它的`多项式表达式`是`(n)`，等价的`元组表达式`就是`(1,2,3,...)`，所以可以找到A的所有B祖先\n\n### 定义\n\n还记得上一篇讲过的`属性名`吗？其中的`index`、`depth`是确定两个节点之间关系的关键\n\n> `A +(a1,a2,a3,a_n) B` :  A.index 满足 B.index-(a_m), 其中 a_m 是元组的任意一个数字\n>\n> `A -(a1,a2,a3,a_n) B` : A.index 满足 B.index+(a_m)\n>\n> `A >(a1,a2,a3,a_n) B` : A.depth 满足 B.depth-(a_m), 根节点的 depth=0\n>\n> `A <(a1,a2,a3,a_n) B` : A.index 满足 a_m-1\n>\n> `A <<(a1,a2,a3,a_n) B` : A.order 满足 a_m-1, A.order（无法通过网页审查工具得知） 是深度优先先序遍历的索引 (搭配 quickFind 使用)\n\n所以，确定两个节点的关系关键在于`index`和`depth`的值，而不是单纯的数户口。\n\n例如：现在有2个`FrameLayout`，其中一个的`index`值是0，另一个的`index`值是3，但是它们在网页审查工具中是相邻的节点。如果你要使用`-`关系操作符选中`index`为3的`FrameLayout`，这时规则就不能写成`@FrameLayout[index=3] - FrameLayout[index=0]`了，而应写成`@FrameLayout[index=3] -3 FrameLayout[index=0]`。当然，实际中写成`FrameLayout[index=3]`会更好。\n\n### 简写\n\n> 当 a=0 或 b=0 时, 括号可以省略, 比如 `A +(3n+0) B` -> `A +(3n) B` -> `A +3n B`，`A +(0n+3) B` -> `A +(+3) B` -> `A +3 B`\n>\n> 当 a=0 且 b=1 时, an+b 可以省略, 比如 `A <(0n+1) B` -> `A < B`, 此外 `A + B`,`A > B` 都与等价的 css 语法语义相同\n>\n> 当 a=1 且 b=0 且操作符是 `>`, 可以进一步简写, 比如 `A >(1n+0) B` -> `A >n B` -> `A B`, 这与等价的 css 语法语义相同\n\n当然，不简写也是可以的，就是会丧失一些代码的简洁性\n\n# 后记\n\n那么，GKD规则编写之选择器的教程就到此结束，也欢迎在评论区留言探讨。\n\n如果本教程有什么谬误，或者对本教程有什么建议的话，也欢迎在下方评论区给出你的建议。\n\n本篇教程不算太完善，以后会慢慢优化的。\n\n那么，祝你写的规则不会误触，不会失效！\n"},{"title":"MakeGKDInspectBetter：一年多的发展","tags":["GKD","GKD 网页审查工具"],"categories":[],"author":"Adpro","excerpt":"\n# 0. 写在前面\n\nMakeGKDInspectBetter，或者说更熟悉的：GKD网页审查工具增强脚本，\n\n是一个提高GKD网页审查工具使用体验的用户脚本。\n\n它可以被绝大多数的用户脚本加载器加","link":"/posts/MakeGKDInspectBetter%EF%BC%9A%E4%B8%80%E5%B9%B4%E5%A4%9A%E7%9A%84%E5%8F%91%E5%B1%95","content":"\n# 0. 写在前面\n\nMakeGKDInspectBetter，或者说更熟悉的：GKD网页审查工具增强脚本，\n\n是一个提高GKD网页审查工具使用体验的用户脚本。\n\n它可以被绝大多数的用户脚本加载器加载，包括但不限于：`TemperMonkey`、`ScriptCat`。\n\n其最初版本诞生于2024年3月3日，彼时它的名字仍然叫做：GKD网页审查工具**复制**增强。\n\n这篇博文，主要总结下该脚本的发展历程，以及部分代码的讲解。\n\n该脚本的发展历程，我觉得可以分为三个阶段：`按钮监听阶段`、`复制监听阶段`以及`大杂烩阶段`。\n\n# 1. 发展历程\n\n## 1.1 按钮监听阶段\n\n得益于`Greasyfork`的更新记录，我们得已看到最初版的脚本是怎么样的：\n\n![初版代码](https://cdn.jsdelivr.net/gh/adproqwq/picx-images-hosting@master/MakeGKDInspectBetter-1.png)\n\n可以看到，初代脚本通过`MutationObserver`去检测复制按钮是否出现并监听其点击事件去显示菜单，\n\n功能也只有修改规则名称和描述。\n\n那么为什么需要去检测按钮是否出现呢？\n\n是因为GKD网页审查工具使用`Vue`去编写，DOM元素并不是进入网页就加载的。\n\n在3月3日和3月4日进行了多次的迭代，使用`layui`美化了界面，\n\n同时对监听按钮事件的方法进行了一次迭代：\n\n![1.0.0](https://cdn.jsdelivr.net/gh/adproqwq/picx-images-hosting@master/MakeGKDInspectBetter-2.png)\n\n可以看到，在1.0.0版本使用了`document.onreadystatechange`。\n\n在这个版本中，给每个复制按钮附加了点击事件，去弹出菜单。\n\n后续的这方面的修改基本都是这两种方法的混合使用，和缝缝补补，在此不作赘述。\n\n## 1.2 复制监听阶段\n\n该阶段开始于4月24日更新的1.5.0版本：\n\n![1.5.0](https://cdn.jsdelivr.net/gh/adproqwq/picx-images-hosting@master/MakeGKDInspectBetter-3.png)\n\n可以看到，这时候已经使用了覆写函数的方式去实现复制的监听。\n\n通过查看GKD网页审查工具的源代码可知，复制使用的是`navigator.clipboard.writeText`函数，\n\n所以我们通过覆写该函数就可以实现复制的监听，从而摆脱低效的DOM节点监听。\n\n事实上，直到如今依然使用的是复制监听的方法。\n\n只不过，从8月2日提交的1.6.4版本，将原来的覆写函数方式，修改为了更优雅的写法：`Proxy`与`Reflect`的配合写法：\n\n![1.6.4](https://cdn.jsdelivr.net/gh/adproqwq/picx-images-hosting@master/MakeGKDInspectBetter-4.png)\n\n使用`Proxy`代理`navigator.clipboard.writeText`函数，\n\n使用`Reflect`在`Proxy`内调用`navigator.clipboard.writeText`函数。\n\n之后不久，使用由`GKD`开发者`@lisonge`的一个`Vite`插件，使用Vue去重构了整个插件，将所有代码开源至`Github`，使用`mdui`重写UI界面。\n\n## 1.3 大杂烩阶段\n\n从理论来讲，这一阶段其实属于复制监听阶段，但我还是将其独立出来，作为一个新的阶段。\n\n该阶段开始于8月29日。\n\n当时，除了这个脚本之外，我还另外维护了两个脚本：`GKD网页审查工具规则快捷搜索`和`GKD网页审查工具自动showSize`。\n\n在8月29日，将`GKD网页审查工具规则快捷搜索`脚本整合进了`GKD网页审查工具复制增强`脚本中，\n\n也是从这时起，这个脚本改名成了：`GKD网页审查工具增强`。\n\n正是这一次的整合，才被我称为大杂烩，也是我将其独立作为一个阶段的原因：将其他的增强性脚本统一进了一个脚本中。\n\n这是一个全新的阶段，这个阶段的版本迭代中，不断开拓出了新的增强方式，这将在下节的代码讲解中一并提到。\n\n# 2. 代码讲解\n\n## 2.1 activityIds规则复制优化\n\n为什么要讲这个？\n\n因为这是脚本第一次涉及`indexedDB`内的数据。\n\n这是其具体的实现代码：\n\n```typescript\nexport const simplyActivityIds = async (\n  snapshotId: string,\n): Promise<string | false> => {\n  const snapshotInfo = await snapshotStorage.getItem<Snapshot>(snapshotId);\n  const activityId = snapshotInfo?.activityId;\n\n  if (activityId) {\n    const appId = snapshotInfo.appId;\n    if (activityId.startsWith(appId) && activityId[appId.length] === '.') {\n      const simplyActivityIds = activityId.replace(appId, '');\n\n      return simplyActivityIds;\n    } else return false;\n  } else return false;\n};\n```\n\n可以看到这一句：\n\n```typescript\nconst snapshotInfo = await snapshotStorage.getItem<Snapshot>(snapshotId);\n```\n\n这是在读取网页审查工具存储的快照信息。\n\n整段代码主要的作用就是：判断activityId的开头是否与appId相同，若相同，则返回去除相同部分的activityId；若不相同，则返回完整的activityId。\n\n那么有人要问了，`if`内直接调用`startsWith`方法不就可以了吗？\n\n为什么还要加上一句\n\n```typescript\nactivityId[appId.length] === '.'\n```\n\n举个例子就明白了。\n\n例如现在有一个软件，包名是`test.example.com`，\n\n它分别有activityId为`test.example.com.Main`和`test.example.com123.Share`的页面，\n\n如果使用`startsWith`方法，那么两者判断都为`true`，\n\n那么最后返回的结果就是：`.Main`和`123.Share`。\n\n这很显然出现了问题，所以才要加上这个判断，\n\n确保包名后接的是分隔符`.`，才返回`true`。\n\n由此开始，基于修改`indexedDB`数据的`节点隐私打码`功能上线了。\n\n## 2.2 节点隐私打码\n\n这段代码比较复杂，所以仅节选部分作为展示、讲解。\n\n这是其核心实现代码：\n\n```typescript\ninterface EditNodeOption {\n  target: AttrList;\n  value: PrimitiveType;\n};\n\nexport const editNode = async (\n  snapshotId: string,\n  nodeId: number,\n  options: EditNodeOption[],\n): Promise<boolean> => {\n  try {\n    const snapshotInfo = await snapshotStorage.getItem<Snapshot>(snapshotId);\n\n    const nodes = snapshotInfo!.nodes;\n    const nodeAttr = nodes[nodeId].attr;\n\n    options.forEach(\n      (option) => ((nodeAttr[option.target] as PrimitiveType) = option.value),\n    );\n\n    nodes[nodeId].attr = nodeAttr;\n    snapshotInfo!.nodes = nodes;\n\n    await snapshotStorage.setItem(snapshotId, snapshotInfo);\n\n    return true;\n  } catch {\n    return false;\n  }\n};\n```\n\n通过给`editNode`函数传入要修改的节点id和要修改的节点信息，用传入的信息覆盖原本的节点信息，达到给节点打码的效果。\n\n```typescript\ninterface EditNodeOption {\n  target: AttrList;\n  value: PrimitiveType;\n};\n```\n\n此处的`target`为修改的属性，如：`text`、`desc`等；`value`则是属性的内容，需要符合`target`接受的类型。\n\n## 2.3 坐标生成\n\n### 2.3.1 背景\n\n这部分内容是该脚本以及我第一次使用`canvas`的实验，具有一定的意义。\n\n先讲讲为什么我们需要这个功能。\n\n在2024年，相对坐标点击刚出现的那会儿，相对坐标是要人工计算的。\n\n[@AIsouler](https://github.com/AIsouler)总结出了计算公式，但是由于Q群炸了，Github提交历史也太过久远，就不放截图了。\n\n后来虽然网页审查工具也上线了相对坐标和绝对坐标的查看，但是计算依旧要人工进行。\n\n这就是这个功能诞生的原因。\n\n### 2.3.2 代码简释\n\n这部分代码很长，所以分开来讲。\n\n先看一下获取信息这部分的代码：\n\n```typescript\nexport const getInfo = async (): Promise<\n  [\n    HTMLCanvasElement,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    HTMLImageElement,\n  ]\n> => {\n  const canvas = document.querySelector('#canvas')! as HTMLCanvasElement;\n\n  const snapshotId = getSnapshotId();\n  const screenshot = await getScreenshot(snapshotId);\n  const nodeId = getCurrentNodeId();\n\n  const screenWidth = (await getScreenInfo(getSnapshotId())).width;\n  const screenHeight = (await getScreenInfo(getSnapshotId())).height;\n  const left = (await getNodeAttr(snapshotId, nodeId, 'left')!) as number;\n  const top = (await getNodeAttr(snapshotId, nodeId, 'top')!) as number;\n  const width = (await getNodeAttr(snapshotId, nodeId, 'width')!) as number;\n  const height = (await getNodeAttr(snapshotId, nodeId, 'height')!) as number;\n\n  const fullImg = arrayBufferToImage(screenshot);\n\n  return [canvas, screenWidth, screenHeight, left, top, width, height, fullImg];\n};\n```\n\n这些都比较好懂，大部分都是用我自封装的函数去获取的快照内部，或者DOM节点信息，\n\n所以这里只解释一个点：\n\n```typescript\nconst fullImg = arrayBufferToImage(screenshot);\n```\n\n这里用来获取快照截图，网页审查工具使用`ArrayBuffer`存储截图信息，所以这里我使用自封装的函数将其转为`HTMLImageElement`，怎么转换具体自行搜索。\n\n然后看一下双视图的实现：\n\n```typescript\nexport const partialView = (\n  canvas: HTMLCanvasElement,\n  screenWidth: number,\n  screenHeight: number,\n  left: number,\n  top: number,\n  width: number,\n  height: number,\n  fullImg: HTMLImageElement,\n) => {\n  window.Hanashiro.currentPositionView = 'partial';\n\n  const ctx = canvas.getContext('2d')!;\n\n  const tampCanvas = document.createElement('canvas');\n  const tampCtx = tampCanvas.getContext('2d')!;\n\n  canvas.width = width;\n  canvas.height = height;\n\n  tampCanvas.width = screenWidth;\n  tampCanvas.height = screenHeight;\n\n  tampCtx.drawImage(fullImg, 0, 0, screenWidth, screenHeight);\n  const imgData = tampCtx.getImageData(left, top, width, height);\n\n  ctx.putImageData(imgData, 0, 0);\n};\n\nexport const globalView = (\n  canvas: HTMLCanvasElement,\n  screenWidth: number,\n  screenHeight: number,\n  fullImg: HTMLImageElement,\n) => {\n  window.Hanashiro.currentPositionView = 'global';\n\n  const ctx = canvas.getContext('2d')!;\n\n  canvas.width = screenWidth;\n  canvas.height = screenHeight;\n\n  ctx.drawImage(fullImg, 0, 0, screenWidth, screenHeight);\n};\n```\n\n全局视图（即`globalView`）没什么好说的，就是用传入的信息，然后整张图贴上去。\n\n我们来看局部视图（`partialView`）。\n\n首先是传入需要的信息，这不必多说，\n\n```typescript\nwindow.Hanashiro.currentPositionView = 'partial';\n```\n\n这句是储存当前视图模式。\n\n我们看到，除了传入的`canvas`之外，还创建了一个`tampCanvas`~~（其实应该是`tempCanvas`，我脑瘫打错了，现在懒得改了）~~，这是用来干什么的？\n\n局部视图，就是只展示节点对应部分的图片，这意味着我们需要对图片进行局部展示。\n\n所以我们先用一个创建一个不展示到页面中的`canvas`，将整张图贴上去，\n\n之后调用`getImageData`方法，将节点对应部分的图片给截下来，\n\n然后再在对用户可见的`canvas`中把获取到的图片给画上去。\n\n我们最后再来看坐标计算的代码：\n\n```typescript\nexport default async () => {\n  const [canvas, screenWidth, screenHeight, left, top, width, height, fullImg] =\n    await getInfo();\n\n  fullImg.onload = () =>\n    partialView(\n      canvas,\n      screenWidth,\n      screenHeight,\n      left,\n      top,\n      width,\n      height,\n      fullImg,\n    );\n\n  canvas.onclick = (e) => {\n    let x = e.offsetX,\n      y = e.offsetY;\n\n    if (window.Hanashiro.currentPositionView == 'global') {\n      x -= left;\n      y -= top;\n    }\n\n    const absolutePosition: Position = {\n      left: left + x,\n      top: top + y,\n    };\n    const relativePosition: Position = {\n      left: `width * ${String((x / width).toFixed(4))}`,\n      top: `width * ${String((y / width).toFixed(4))}`,\n    };\n\n    window.Hanashiro.nodePosition = {\n      absolute: absolutePosition,\n      relative: relativePosition,\n    };\n\n    const result = document.querySelector('#result')! as Dialog;\n    result.open = true;\n  };\n};\n```\n\n一开始默认使用局部视图，所以在获取到截图后就调用`partialView`函数。\n\n通过获取`canvas` `click`事件的`offsetX`和`offsetY`，我们可以知道用户点击了`canvas`的哪个地方，从而计算其坐标。\n\n由于在局部视图中，获取到的坐标需要通过分别加上节点的`left`和`top`属性来计算其绝对坐标，而在全局视图中不需要。\n\n所以为了坐标计算的通用性，如果为全局视图，就先分别减去`left`和`top`属性，这样加回来之后，坐标就还是正确的。\n\n```typescript\nif (window.Hanashiro.currentPositionView == 'global') {\n  x -= left;\n  y -= top;\n}\n```\n\n这就是这段代码的意义。\n\n相对坐标的计算就是套[@AIsouler](https://github.com/AIsouler)的计算公式了。\n\n总的而言，功能实现其实就这么点，但是由于我在开头说了，这是我第一次实践`canvas`，所以资料也查了很多，踩的坑也不少。\n\n不过总算是把这个功能写出来了，也算是可喜可贺。\n\n# 3. 写在最后\n\n这篇文章仅作总结使用，代码的说明后续会挑选一些功能的代码继续更新。\n\n如果有人对代码有更好的优化建议，也欢迎到Github仓库发起PR。\n\n如果有人因此脚本有所启发，开发出更好用的脚本，那就再好不过了。"},{"title":"P2669金币-题解","tags":["洛谷","题解","Python"],"categories":[],"author":"Adpro","excerpt":"\n# 题目\n\n## P2669 [NOIP2015 普及组] 金币\n\n### 题目背景\n\nNOIP2015 普及组 T1\n\n### 题目描述\n\n国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一","link":"/posts/P2669%E9%87%91%E5%B8%81-%E9%A2%98%E8%A7%A3","content":"\n# 题目\n\n## P2669 [NOIP2015 普及组] 金币\n\n### 题目背景\n\nNOIP2015 普及组 T1\n\n### 题目描述\n\n国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续 n 天每天收到 n 枚金币后，骑士会在之后的连续 n+1 天里，每天收到 n+1 枚金币。\n\n请计算在前 k 天里，骑士一共获得了多少金币。\n\n### 输入格式\n\n一个正整数 k，表示发放金币的天数。\n\n### 输出格式\n\n一个正整数，即骑士收到的金币数。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n6\n```\n\n#### 样例输出 #1\n\n```\n14\n```\n\n### 样例 #2\n\n#### 样例输入 #2\n\n```\n1000\n```\n\n#### 样例输出 #2\n\n```\n29820\n```\n\n### 提示\n\n**【样例 1 说明】**\n\n骑士第一天收到一枚金币；第二天和第三天，每天收到两枚金币；第四、五、六天，每天收到三枚金币。因此一共收到 1+2+2+3+3+3=14 枚金币。\n\n\n对于 100% 的数据，$1\\le k\\le 10^4$。\n\n# 分析\n\n```python\nk = int(input())\na = 1\nsum = 1\nans = 0\nfor i in range(1,k+1):\n    ans+=a\n    if sum == a:\n        sum = 1\n        a+=1\n    else:\n        sum+=1\nprint(ans)\n```\n\n我们可以通过定义一个 a，来表示第 i 天应该发放的工资数。\n\n> 当连续 n 天每天收到 n 枚金币后，骑士会在之后的连续 n+1 天里，每天收到 n+1 枚金币。\n\n这段话概括起来即是：骑士获得 a 个金币的工资持续的天数是 a 天。\n\n那么，我们可以通过 sum 来计算当前是每天拿 a 个金币的第几天。\n\n当 sum == a 时，就是下一天工资就需要加多1个金币。\n"},{"title":"关于 Milthm 由单曲 Reality 计算单曲分数的函数","tags":["Milthm","查分","音游"],"categories":["音游","Milthm"],"author":"Adpro","excerpt":"\n在一切开始之前，我们需要援引一下[@mkzi-nya](https://github.com/mkzi-nya/)，也就是归梦在之前发布的研究成果。\n\n给定分数 $s$ 和定数 $c$，则有关于 $","link":"/posts/%E5%85%B3%E4%BA%8E%20Milthm%20%E7%94%B1%E5%8D%95%E6%9B%B2%20Reality%20%E8%AE%A1%E7%AE%97%E5%8D%95%E6%9B%B2%E5%88%86%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0","content":"\n在一切开始之前，我们需要援引一下[@mkzi-nya](https://github.com/mkzi-nya/)，也就是归梦在之前发布的研究成果。\n\n给定分数 $s$ 和定数 $c$，则有关于 $s$ 和 $c$ 的函数\n\n$$\nr(s,c)=\n\n\\left\\{\n\n  \\begin{array}{lr}\n\n    0, & \\quad c\\in(-\\infty,0.001) \\\\\n\n    c+1, & \\quad s\\in[1005000,1001000] \\\\\n\n    \\dfrac{1.4}{e^{3.65\\cdot(99.5-\\frac{s}{10000})}+1}+c-0.4, & \\quad s\\in[995000,1005000) \\\\\n\n    \\dfrac{e^{3.1\\cdot\\frac{s-980000}{15000}}-1}{e^{3.1}-1}\\cdot0.8+c-0.5, & \\quad s\\in[980000,995000) \\\\\n\n    \\dfrac{s}{280000}+c-4, & \\quad s\\in[700000,980000) \\\\\n\n    0, & \\quad s\\in(-\\infty,700000) \\\\\n\n  \\end{array}\n\n\\right.\n$$\n\n可以看到，函数 $r$ 拥有两个变量。但是我们不妨想一下，对于同一首歌，它的定数是唯一确定的，所以对于同一首歌，我们不妨将变量 $c$ 看作一个常数。\n\n那么当我们排除掉 $r(c)=0, \\quad c\\in(-\\infty,0.001)$ 这个仅受变量 $c$ 影响的函数后，有关 $s$ 的函数\n\n$$\nr(s)=\n\n\\left\\{\n\n  \\begin{array}{lr}\n\n    c+1, & \\quad s\\in[1005000,1001000] \\\\\n\n    \\dfrac{1.4}{e^{3.65\\cdot(99.5-\\frac{s}{10000})}+1}+c-0.4, & \\quad s\\in[995000,1005000) \\\\\n\n    \\dfrac{e^{3.1\\cdot\\frac{s-980000}{15000}}-1}{e^{3.1}-1}\\cdot0.8+c-0.5, & \\quad s\\in[980000,995000) \\\\\n\n    \\dfrac{s}{280000}+c-4, & \\quad s\\in[700000,980000) \\\\\n\n    0, & \\quad s\\in(-\\infty,700000) \\\\\n\n  \\end{array}\n\n\\right.\n$$\n\n让我们看看它的函数图像：\n\n![最小值函数图像](https://cdn.jsdelivr.net/gh/adproqwq/picx-images-hosting@master/最小值函数图像.pfmng4eb1.jpg)\n\n这是当它在目前定数最小值：1时的图像。函数的最小值约在 $x=700000$ 处取得（实际约在$x=700000.012373348$ 处取得）。\n\n![中间值函数图像](https://cdn.jsdelivr.net/gh/adproqwq/picx-images-hosting@master/中间值函数图像.3rbioo8xjk.jpg)\n\n这是在极值之间任意取的一个数的函数图像。\n\n![最大值函数图像](https://cdn.jsdelivr.net/gh/adproqwq/picx-images-hosting@master/最大值函数图像.1zijtrs0wf.jpg)\n\n这是当它在目前定数最大值：12.3时的图像。\n\n我们可以清楚地看到，函数 $r$ 在我们实际需要去计算单曲 Reality 的分数段 $s\\in[700000,1010000]$ 内是单调递增的。\n\n由于函数 $r$ 在 $s\\in[700000,1010000]$ 内具有单调性，所以我们理应可以求得函数 $r$ 的反函数。\n\n根据一些计算，我们可以得到函数 $r$ 的反函数\n\n$$\ns(r)=\n\n\\left\\{\n\n  \\begin{array}{lr}\n\n    10000\\left(99.5-\\dfrac{1}{3.65}\\ln\\left(\\dfrac{c-r+1}{r-c+0.4}\\right)\\right), & \\quad r\\in\\left[c+0.3,c+\\dfrac{1.4}{e^{-3.65}+1}-0.4\\right) \\\\\n\n    \\dfrac{15000}{3.1}\\ln\\left(\\dfrac{(r-c+0.5)(e^{3.1}-1)}{0.8}+1\\right)+980000, & \\quad r\\in[c-0.5,c+0.3) \\\\\n\n    280000(r-c+4), & \\quad r\\in[c-1.5,c-0.5) \\\\\n\n  \\end{array}\n\n\\right.\n$$\n\n同时，由于函数 $r$ 两个极端情况取值为常数，所以有：\n\n当 $r=c+1$ 时， $s\\in[1050000,1010000]$ ；\n\n当 $r=0$ 时， $s\\in(-\\infty,700000)$ 。\n\n由此，我们就获得了由单曲 Reality 计算单曲分数的函数。\n\n同时，由于单曲分数 $s$ 一定满足 $s\\in\\mathbb{N}$，所以实际计算过程中， 某一确定的单曲 Reality $r$ 对应的单曲分数 $s$ 可能是小数，这时可能需要做额外的处理。"},{"title":"关于本人GKD订阅终止维护的通知","tags":["GKD"],"categories":[],"author":"Adpro","excerpt":"Adpro订阅在2024年5月13日，迎来了终点。\n\n---\n\nAdpro订阅诞生于2024年1月28日。那时，GKD默认订阅宣布停止维护，我用了一个小时（可能更长，也可能更短），fork了仓库，修改","link":"/posts/%E5%85%B3%E4%BA%8E%E6%9C%AC%E4%BA%BAGKD%E8%AE%A2%E9%98%85%E7%BB%88%E6%AD%A2%E7%BB%B4%E6%8A%A4%E7%9A%84%E9%80%9A%E7%9F%A5","content":"Adpro订阅在2024年5月13日，迎来了终点。\n\n---\n\nAdpro订阅诞生于2024年1月28日。那时，GKD默认订阅宣布停止维护，我用了一个小时（可能更长，也可能更短），fork了仓库，修改了配置，迁移了尚未合并的规则，发布了v0版本。\n\n维护期间，也帮助了一些原来的规则贡献者搭建了第三方订阅，包括aoguai、AIsouler订阅。\n\n在维护订阅的同时，我新建了[`GKD_THS_List`](https://github.com/Adpro-Team/GKD_THS_List)仓库，收录了不少的第三方订阅。开发了现在的GKDTool网页端（在默认订阅时期开发，后来发展出了安卓端，又用Vue重构写了GKDTool 2.0）、开发了李跳跳规则转GKD规则的工具（从开始的命令行，发展到了网页端）。\n\n可以说，维护订阅的将近4个月，我承担了以上所有工具的维护，同时还要维护订阅。\n\n也是由于此，可以发现，Adpro订阅开始同步AIsouler订阅，没有自己的更新。\n\n这种情况的出现，实际上也让Adpro订阅名存实亡。\n\n所以，Adpro订阅仓库归档，不再维护。\n\n如果是群友，可能看过我说的这句话：\n\n![言论](https://cdn.jsdelivr.net/gh/adproqwq/picx-images-hosting@master/言论.8ojil6ujxt.png)\n\n我想说的是，我从来没有想过能达到这个目标，所以我说了这句话。\n\n但这并不是我终止维护的主要原因。原因在上面已经说得很清楚了。\n\n在此也要说明，此次的终止维护，完全出于个人原因，没有任何外部因素。\n\n就这样吧。\n\n写于2024.5.14\n\n---\n\n其它的工具不会终止维护。"},{"title":"哲学的基本问题和两大派别","tags":["哲学","政治","高中","笔记"],"categories":["笔记","高中","政治"],"author":"Adpro","excerpt":"\n# 零、写在前面\n\n这是随便写写的笔记，主要写我的理解，所以可能有不正确的内容，不建议作为个人自学的资料！\n\n# 一、哲学的基本问题\n\n哲学的基本问题是：思维和存在的**关系**问题（或可表述为：意","link":"/posts/%E5%93%B2%E5%AD%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98%E5%92%8C%E4%B8%A4%E5%A4%A7%E6%B4%BE%E5%88%AB","content":"\n# 零、写在前面\n\n这是随便写写的笔记，主要写我的理解，所以可能有不正确的内容，不建议作为个人自学的资料！\n\n# 一、哲学的基本问题\n\n哲学的基本问题是：思维和存在的**关系**问题（或可表述为：意识和物质的**关系**问题）。\n\n思维（意识）是主观的，而存在（物质）则是客观的。\n\n两个表述都是正确的，但存在对应匹配的关系，**思维只能搭配存在，意识只能搭配物质**。\n\n**是关系，而不是辩证关系！**\n\n这当中包含两方面内容：\n\n1. 思维和存在（意识和物质）谁是本原的问题\n2. 思维和存在（意识和物质）有无同一性的问题（思维能否正确认识存在）\n\n对于问题1的不同回答，将哲学划分为两个派别：`唯物主义`和`唯心主义`；对于问题2的不同回答，则存在着`可知论`和`不可知论`的分歧。\n\n## 1. `可知论`和`不可知论`\n\n`可知论`认为思维能够正确认识存在，举个形象的例子：\n\n某地的天气变幻无常，而科研人员通过监测分析得出了该地天气的规律，\n\n这就是思维能够正确认识存在，主观能够正确认识客观。\n\n还是那个例子：\n\n某地的天气变幻无常，但是某人认为，科研人员不能通过监测分析得出该地天气的规律，\n\n那么某人就是认为思维不能正确认识存在，主观不能正确认识客观，这就是`不可知论`。\n\n## 2. `可知论`代表人物\n\n马克思是典型的`可知论`者。\n\n> 世界只有尚未认识之物，没有不可认识之物。——马克思\n\n## 3. `不可知论`代表人物\n\n休谟和康德是其中的代表人物。\n\n> 人类的知识只能基于经验，而关于神或超自然的存在没有经验依据，因此我们无法获知真相。——大卫·修谟\n\n> 我们只能认识现象世界，而自在之物不可知。——伊曼努尔·康德\n\n# 二、哲学的两大派别\n\n由思维和存在（意识和物质）谁是本原的问题，衍生出了哲学的两大派别：`唯物主义`和`唯心主义`。\n\n`唯物主义`和`唯心主义`之间的区别和判断标准就是认为思维和存在（意识和物质）谁是本原。\n\n对思维和存在（意识和物质）谁是本原这一问题，只能是`唯物主义`的或`唯心主义`的，不可能存在第三个答案，一切的二元论（即认为思维和存在（意识和物质）是平行的，都是本原）最终都会滑向`唯心主义`。\n\n## 1. `唯物主义`\n\n`唯物主义`有三种基本形态：`古代朴素唯物主义`、`近代形而上学唯物主义`与`辩证唯物主义`和`历史唯物主义`。\n\n### A. `古代朴素唯物主义`\n\n`古代朴素唯物主义`将世界本原归结于一种或几种的具体物质形态，带有明显的朴素和直观色彩。\n\n中国古代的`五行说`、荀子、王充、王夫之、管子和古希腊的泰勒斯、赫拉克利特、德谟克利特都是`古代朴素唯物主义`的代表。\n\n> 天地合而万物生，阴阳接而变化起。——荀子\n> 天行有常，不为尧存，不为桀亡。——荀子\n\n> 天地合气，万物自生。——王充\n\n> 气者，理之依也。——王夫之\n\n> 水者，何也？万物之本原也。——《管子》\n\n> 水是万物的始基。——泰勒斯\n\n> 世界是一团永恒燃烧的活火。——赫拉克利特\n\n> 原子是世界的共同基础。——德谟克利特\n\n### B. `近代形而上学唯物主义`\n\n`近代形而上学唯物主义`将自然科学中不可再分的、最小的物质结构，如原子，看作世界的本质，这丰富了`唯物主义`的物质观，但它将自然科学的物质结构直接混同于物质概念，把原子的属性混同于物质的属性，把世界万物的运动归结为受力学支配的机械运动，所以具有机械性、形而上学性和历史观上的`唯心主义`等局限。\n\n#### a. `形而上学`\n但是什么是`形而上学`？\n\n`形而上学`就像人类对世界的终极追问，研究那些肉眼看不见但可能存在的根本问题，它试图回答一切为什么之后的为什么。\n\n科学研究是什么和怎么办，而`形而上学`研究为什么和凭什么。\n\n#### b. `形而上学`的特点\n\n`形而上学`认为\n\n1. 世界是静止不变的；\n2. 事物之间是孤立割裂的；\n3. 矛盾是非黑即白的。\n\n#### c. `近代形而上学唯物主义`的出现背景\n`近代形而上学唯物主义`的出现有其背景。\n\n1. 当时牛顿力学盛行，`近代形而上学唯物主义`者误以为机械运动是宇宙终极规律；\n2. 自然科学盛行`分析法（拆解研究）`，哲学照搬成世界观；\n3. 资产阶级革命需要稳定不变的自然秩序对抗教会神学。\n\n#### d. `近代形而上学唯物主义`的代表\n\n培根和狄德罗是`近代形而上学唯物主义`的代表人物。\n\n> 万物的基础是原始物质，是基本元素。——弗兰西斯·培根\n\n> 自然界由数目无穷、性质不同的异质元素构成。——德尼·狄德罗\n> 如果自然界是运动的物质，那么一切现象都可以用物质和运动来解释。——德尼·狄德罗\n\n### C. `辩证唯物主义`和`历史唯物主义`\n\n#### a. 概念\n\n`马克思主义哲学`就是`辩证唯物主义`和`历史唯物主义`。\n\n它认为：物质是不依赖于人的意识，并能为人的意识所反映的客观**实在**。客观实在性是物质的唯一特性。\n\n客观**实在**与客观**存在**是不一样的，需要区分。\n\n#### b. 客观实在与客观存在\n\n客观实在和客观存在，区别就在于**实**和**存**两个字。\n\n顾名思义，客观实在应该要在客观世界中**真实**存在，无论你是否观察到它，都在客观世界中客观存在。\n\n而客观存在则只需要存在就好，客观存在既包含物质实体，也包含**依赖人类意识的抽象存在**，当人类消失，**依赖人类意识的抽象存在**也随之消失，也就不再**存在**了。\n\n客观实在必定客观存在，但客观存在的不一定客观实在（比如`0`这个数字符号是客观存在的概念，但不是客观实在的物质）\n\n## 2. `唯心主义`\n\n`唯心主义`有两种基本形态：`主观唯心主义`和`客观唯心主义`。\n\n### A. `主观唯心主义`\n\n`主观唯心主义`把人的主观精神，如人的目的、意志、感觉、经验、心灵等，理解为世界的本原，认为客观事物乃至整个世界，都依赖于人的主观精神。\n\n贝克莱、王阳明、笛卡尔、普罗泰戈拉是其中代表人物。\n\n> 存在即被感知。——乔治·贝克莱\n> 物是观念的集合。——乔治·贝克莱\n\n> 心外无物，心外无理。——王阳明\n> 你未看此花时，此花与汝心同归于寂；你来看此花时，此花颜色一时明白起来。——王阳明\n\n> 我思故我在。——笛卡尔\n\n> 人是万物的尺度。——普罗泰戈拉\n\n### B. `客观唯心主义`\n\n`客观唯心主义`把客观精神，如上帝、神、理念、绝对精神等，看作世界的主宰和本原，认为现实的物质世界只是这些客观精神的外化和表现。\n\n朱熹、柏拉图、黑格尔是其中代表人物，神创论也是一种`客观唯心主义`。\n\n> 未有此气，已有此理。——朱熹\n\n> 世界是“理念”的影子。——柏拉图\n\n> 绝对精神是世界的本质。——黑格尔\n\n## 3. 总结\n\n`唯物主义`和`唯心主义`、`辩证法`和`形而上学`之间的对立和斗争长期存在，但这些对立和斗争归根结底，只有`唯物主义`和`唯心主义`两种。\n\n> 透过许多新奇的诡辩言词和学究气十足的烦琐语句，我们总是毫无例外地看到，在解决哲学问题上有两条基本路线、两个基本派别。——列宁\n\n# 三、后记\n\n本文可能存在不少谬误，欢迎指正！\n\n后续可能还会更新其他的笔记，这次主要是针对刚学的哲学基本问题和两大派别写的一点东西，后续学到啥难理解的可能就会写了 ~~，也有可能根本坚持不下来（~~ 。"},{"title":"寂しい夏のせいにして　歌词+罗马音","tags":["歌词","日语","罗马音","寂しい夏のせいにして"],"categories":["歌词","日语"],"author":"Adpro","excerpt":"\n为避免版权风险，本贴仅含日语原文歌词及其罗马音，不包含任何翻译。\n\n非日语专业，如有错误欢迎指出！\n\n---\n\n<meting-js\n id=\"1954947025\"\n server=\"neteas","link":"/posts/%E5%AF%82%E3%81%97%E3%81%84%E5%A4%8F%E3%81%AE%E3%81%9B%E3%81%84%E3%81%AB%E3%81%97%E3%81%A6%20%E6%AD%8C%E8%AF%8D+%E7%BD%97%E9%A9%AC%E9%9F%B3","content":"\n为避免版权风险，本贴仅含日语原文歌词及其罗马音，不包含任何翻译。\n\n非日语专业，如有错误欢迎指出！\n\n---\n\n<meting-js\n id=\"1954947025\"\n server=\"netease\"\n type=\"song\"\n theme=\"#39C5BB\">\n</meting-js>\n\nありふれた<ruby>話<rt>はなし</rt></ruby>の<ruby>続<rt>つづ</rt></ruby>きをしてよう\n\na ri hu re ta ha na shi no tsu du ki wo shi yo u\n\nほら　<ruby>忘<rt>わす</rt></ruby>れてしまう<ruby>前<rt>まえ</rt></ruby>に\n\nho ra wa su re te shi ma u ma e ni\n\n<ruby>花束<rt>はなたば</rt></ruby>を<ruby>浮<rt>う</rt></ruby>かべた<ruby>水溜<rt>みずたま</rt></ruby>りには\n\nha na ta ba wo u ka be ta mi zu ta ma ri ni ha\n\nまだ　あなたが<ruby>映<rt>うつ</rt></ruby>っていた\n\nma da a na ta ga u tsu tte i ta\n\n<ruby>簡単<rt>かんたん</rt></ruby>じゃないけど\n\nka n ta n ja na i ke do\n\nこの<ruby>隙間<rt>すきま</rt></ruby>を<ruby>埋<rt>う</rt></ruby>めて\n\nko no su ki ma wo u me te\n\n<ruby>本心<rt>ほんしん</rt></ruby>じゃなくても　<ruby>笑<rt>わら</rt></ruby>っていて\n\nho n shi n ja na ku te mo wa ra tte i te\n\n<ruby>散<rt>さん</rt></ruby>々な<ruby>今日<rt>きょう</rt></ruby>でも\n\nsa n za n na kyo u de mo\n\n<ruby>誤魔化<rt>ごまか</rt></ruby>して<ruby>生<rt>い</rt></ruby>きていて\n\ngo ma ka shi te i ki te i te\n\nあなたは<ruby>言<rt>い</rt></ruby>う　<ruby>私<rt>わたし</rt></ruby>が<ruby>浮<rt>う</rt></ruby>かぶ\n\na na ta ha i u wa ta shi ga u ka bu\n\n<ruby>明日<rt>あした</rt></ruby>また<ruby>会<rt>あ</rt></ruby>えるなら\n\na shi ta ma ta a e ru na ra\n\nあなたは\n\na na ta ha\n\nいまの<ruby>顔<rt>かお</rt></ruby>のままでいてね\n\ni ma no ka o no ma ma de i te ne\n\n<ruby>寂<rt>さび</rt></ruby>しい<ruby>夏<rt>なつ</rt></ruby>のせいにして\n\nsa bi shi i na tsu no se i ni shi te\n\n<ruby>私<rt>わたし</rt></ruby>は<ruby>泣<rt>な</rt></ruby>いてしまった\n\nwa ta shi ha na i te shi ma tta\n\n<ruby>抱<rt>だ</rt></ruby>きしめていた\n\nda ki shi me te i ta\n\n<ruby>思<rt>おも</rt></ruby>い<ruby>出<rt>で</rt></ruby>が<ruby>少<rt>すこ</rt></ruby>しずつ\n\no mo i de ga su ko shi zu tsu\n\nズレていくように\n\nzu re te i ku yo u ni\n\nほら　<ruby>二人<rt>ふたり</rt></ruby>の<ruby>距離<rt>きょり</rt></ruby>だって\n\nho ra hu ta ri no kyo ri da tte\n\n<ruby>近<rt>ちか</rt></ruby>くて<ruby>遠<rt>とお</rt></ruby>いような<ruby>中途半端<rt>ちゅうとはんぱ</rt></ruby>が\n\nchi ka ku te to o i yo u na chu u to ha n pa ga\n\nまだ　<ruby>胸<rt>むね</rt></ruby>に<ruby>残<rt>のこ</rt></ruby>っていた\n\nma da mu ne ni no ko tte i ta\n\n<ruby>簡単<rt>かんたん</rt></ruby>じゃないけど\n\nka n ta n ja na i ke do\n\nその<ruby>隙間<rt>すきま</rt></ruby>を<ruby>埋<rt>う</rt></ruby>める\n\nso ro su ki ma wo u me ru\n\n<ruby>本心<rt>ほんしん</rt></ruby>じゃなくても　<ruby>笑<rt>わら</rt></ruby>っている\n\nho n shi n ja na ku te mo wa ra tte i ru\n\n<ruby>散<rt>さん</rt></ruby>々な<ruby>今日<rt>きょう</rt></ruby>でも\n\nsa n za n na kyo u de mo\n\n<ruby>誤魔化<rt>ごまか</rt></ruby>して<ruby>生<rt>い</rt></ruby>きている\n\ngo ma ka shi te i ki te i ru\n\n<ruby>私<rt>わたし</rt></ruby>が<ruby>言<rt>い</rt></ruby>う　あなたは<ruby>揺<rt>ゆ</rt></ruby>れる\n\nwa ta shi ga i u a na ta ha yu re ru\n\n<ruby>明日<rt>あした</rt></ruby>また<ruby>会<rt>あ</rt></ruby>えるから\n\na shi ta ma ta a e ru ka ra\n\nあなたは\n\na na ta ha\n\n<ruby>今日<rt>きょう</rt></ruby>と<ruby>同<rt>おな</rt></ruby>じ<ruby>顔<rt>かお</rt></ruby>で<ruby>生<rt>い</rt></ruby>きていて\n\nkyo u to o na ji ka o de i ki te i te\n\n<ruby>寂<rt>さび</rt></ruby>しい<ruby>夏<rt>なつ</rt></ruby>のその<ruby>後<rt>あと</rt></ruby>は\n\nsa bi shi i na tsu no so ro a to ha\n\n<ruby>二人<rt>ふたり</rt></ruby>きり<ruby>何処<rt>どこ</rt></ruby>かへ<ruby>行<rt>い</rt></ruby>こう\n\nhu ta ri ki ri do ko ka he i ko u\n\n<ruby>遠<rt>とお</rt></ruby>くへ<ruby>行<rt>い</rt></ruby>こう\n\nto o ku he i ko u\n\n<ruby>話<rt>はな</rt></ruby>したいこと　<ruby>話<rt>はな</rt></ruby>せていないことも\n\nha na shi ta i ko to ha na se te i na i ko to mo\n\nまだたくさんあるから\n\nma da ta ku sa n a ru ka ra\n\nほら<ruby>愛<rt>あい</rt></ruby>も<ruby>恋<rt>こい</rt></ruby>も<ruby>全部<rt>ぜんぶ</rt></ruby><ruby>全部<rt>ぜんぶ</rt></ruby><ruby>忘<rt>わす</rt></ruby>れないよ\n\nho ra a i mo ko i mo ze n bu ze n bu wa su re na i yo\n\nあなたの<ruby>声<rt>こえ</rt></ruby>を　そのまま\n\na na ta no ko e wo su no ma ma\n\n<ruby>八月<rt>はちがつ</rt></ruby>の<ruby>最後<rt>さいご</rt></ruby>にもう<ruby>一度<rt>いちど</rt></ruby>だけ\n\nha chi ga tsu no sa i go ni mo u i chi do da ke\n\n<ruby>寂<rt>さび</rt></ruby>しい<ruby>夏<rt>なつ</rt></ruby>のせいにして\n\nsa bi shi i na tsu no se i ni shi te\n\n<ruby>私<rt>わたし</rt></ruby>のものにしたいよ\n\nwa ta shi no mo no ni shi ta i yo\n\n<ruby>明日<rt>あした</rt></ruby>また<ruby>会<rt>あ</rt></ruby>えるなら\n\na shi ta ma ta a e ru na ra\n\nあなたは\n\na na ta ha\n\nいまの<ruby>顔<rt>かお</rt></ruby>のままでいてね\n\ni ma no ka o no ma ma de i te ne\n\n<ruby>寂<rt>さび</rt></ruby>しい<ruby>夏<rt>なつ</rt></ruby>のせいにして\n\nsa bi shi i na tsu no se i ni shi te\n\n<ruby>私<rt>わたし</rt></ruby>は<ruby>泣<rt>な</rt></ruby>いてしまった\n\nwa ta shi ha na i te shi ma tta\n\n<ruby>明日<rt>あした</rt></ruby>また<ruby>会<rt>あ</rt></ruby>えるから\n\na shi ta ma ta a e ru ka ra\n\nあなたは\n\na na ta ha\n\n<ruby>今日<rt>きょう</rt></ruby>と<ruby>同<rt>おな</rt></ruby>じ<ruby>顔<rt>かお</rt></ruby>で<ruby>生<rt>い</rt></ruby>きていて\n\nkyo u to o na ji ka o de i ki te i te\n\n<ruby>寂<rt>さび</rt></ruby>しい<ruby>夏<rt>なつ</rt></ruby>のその<ruby>後<rt>あと</rt></ruby>は\n\nsa bi shi i na tsu no so ro a to ha\n\n<ruby>二人<rt>ふたり</rt></ruby>きり<ruby>何処<rt>どこ</rt></ruby>かへ<ruby>行<rt>い</rt></ruby>こう\n\nhu ta ri ki ri do ko ka he i ko u\n\n<ruby>遠<rt>とお</rt></ruby>くへ<ruby>行<rt>い</rt></ruby>こう\n\nto o ku he i ko u\n\n<ruby>縋<rt>すが</rt></ruby>るしかないの\n\nsu ga ru shi ka na i no"},{"title":"随笔","tags":["随笔"],"categories":["随笔"],"author":"Adpro","excerpt":"\n满月之夜，无人教堂之巅。黑猫静坐于此，眼神淡漠。尾尖略微摆动，月光之下的教堂飞出成群的乌鸦。嘘~仔细听，似乎有什么在呻吟呢~\n\n阳光正好，白猫躺在花海中小憩。微风拂过，她惫懒地撑起身子，静静地盯住一","link":"/posts/%E9%9A%8F%E7%AC%94","content":"\n满月之夜，无人教堂之巅。黑猫静坐于此，眼神淡漠。尾尖略微摆动，月光之下的教堂飞出成群的乌鸦。嘘~仔细听，似乎有什么在呻吟呢~\n\n阳光正好，白猫躺在花海中小憩。微风拂过，她惫懒地撑起身子，静静地盯住一处。轻吟一声，又酣然入梦。\n\n**Darkness night, I'll comfront you here.**\n\n白与黑于残垣断壁中相遇。\n\n**I can hurt anyone in the name of justice**\n\n交错的瞬间，世界也被分割成了黑白二色。\n\n**and 「testify」.**\n\n世界「见证」黑的落幕。\n\n混沌正在褪去……\n\n可真的结束了吗？\n\n天翻地覆。\n\n当白以胜利的姿态拔出剑的那刻。\n\n雨。\n\n下雨了。\n\n世界在哀叹黑的落幕吗？\n\n还是新世界的开始？\n\n无尽之雨。\n\n地上很快积起一洼一洼的积水。\n\n雨水滴落，泛起一圈一圈的波纹。\n\n在波纹之中回荡着的，是人的梦。\n\n白。在你的梦中，可有黑的一角？\n\n在已是残垣断壁的「雨之城」，\n\n白已明悟。\n\n这是「命日」。\n\n即使曾一同做着「大月坠落狂想」的梦。\n\n但却该由自己去终结一切。\n\n白与黑逐渐融合了，不分彼此，一如既往。\n\n雨还在下，可梦是甜的。\n\n透过水洼，黑与白正相拥着呢。\n"},{"title":"Adproの标签","tags":[],"categories":[],"author":"Adpro","excerpt":"","link":"/tags","content":""}]
